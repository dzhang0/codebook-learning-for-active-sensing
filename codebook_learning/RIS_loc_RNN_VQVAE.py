# -*- coding: utf-8 -*-
"""RNN_VQVAE_v27_SPAWC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ECd5VJO_qLEAJTLCQ-w2W9a1iz_v0n4
"""

import numpy as np
import scipy.io as sio
import matplotlib.pyplot as plt
import random as random
from mpl_toolkits import mplot3d
import math

def generate_location(num_users):
    location_user = np.empty([num_users, 3])
    for k in range(num_users):
        #x = np.random.uniform(5, 55)
        # y = np.random.uniform(-50, 50)
        x = np.random.uniform(-35, -5)
        y = np.random.uniform(5, 75)
        z = -20
        coordinate_k = np.array([x, y, z])
        location_user[k, :] = coordinate_k
    return location_user

def generate_location_old(num_users):
    location_user = np.empty([num_users, 3])
    for k in range(num_users):
        x = np.random.uniform(5, 35)
        y = np.random.uniform(-35, 35)
        z = -20
        coordinate_k = np.array([x, y, z])
        location_user[k, :] = coordinate_k
    return location_user

def generate_location_2D(num_users):
    location_user = np.empty([num_users, 2])
    for k in range(num_users):
        x = np.random.uniform(5, 35)
        y = np.random.uniform(-35, 35)
        coordinate_k = np.array([x, y])
        location_user[k, :] = coordinate_k
    return location_user

def generate_location_AOA_groups(num_users):  # 32 users, 8,8,8,8
    location_user = np.empty([num_users, 3])
    group_size = int(num_users/4)
    #group1
    sigmax = 1.2 # 3,7
    sigmay = 3
    mu = (12.5,-17.5)
    for k in range(group_size):
        x = random.gauss(mu[0], sigmax)
        y = random.gauss(mu[1], sigmay)
        z = -20
        coordinate_k = np.array([x, y, z])
        location_user[k, :] = coordinate_k

    #group2
    mu = (27.5,-17.5)
    for k in range(group_size):
        x = random.gauss(mu[0], sigmax)
        y = random.gauss(mu[1], sigmay)
        z = -20
        coordinate_k = np.array([x, y, z])
        location_user[group_size+k, :] = coordinate_k

    #group3
    mu = (12.5,17.5)
    for k in range(group_size):
        x = random.gauss(mu[0], sigmax)
        y = random.gauss(mu[1], sigmay)
        z = -20
        coordinate_k = np.array([x, y, z])
        location_user[group_size*2+k, :] = coordinate_k

    #group4
    mu = (27.5,17.5)
    for k in range(group_size):
        x = random.gauss(mu[0], sigmax)
        y = random.gauss(mu[1], sigmay)
        z = -20
        coordinate_k = np.array([x, y, z])
        location_user[group_size*3+k, :] = coordinate_k


    return location_user


def path_loss_r(d):
    loss = 30 + 22.0 * np.log10(d)
    return loss


def path_loss_d(d):
    loss = 32.6 + 36.7 * np.log10(d)
    return loss


def generate_pathloss_aoa_aod(location_user, location_bs, location_irs):
    """
    :param location_user: array (num_user,2)
    :param location_bs: array (2,)
    :param location_irs: array (2,)
    :return: pathloss = (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user)
            cos_phi = (cos_phi_1, cos_phi_2, cos_phi_3)
    """
    num_user = location_user.shape[0]
    # ========bs-irs==============
    d0 = np.linalg.norm(location_bs - location_irs)
    pathloss_irs_bs = path_loss_r(d0)
    aoa_bs = ( location_irs[0] - location_bs[0]) / d0
    aod_irs_y = (location_bs[1]-location_irs[1]) / d0
    aod_irs_z = (location_bs[2]-location_irs[2]) / d0
    # =========irs-user=============
    pathloss_irs_user = []
    aoa_irs_y = []
    aoa_irs_z = []
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_irs)
        pathloss_irs_user.append(path_loss_r(d_k))
        aoa_irs_y_k = (location_user[k][1] - location_irs[1]) / d_k
        aoa_irs_z_k = (location_user[k][2] - location_irs[2]) / d_k
        aoa_irs_y.append(aoa_irs_y_k)
        aoa_irs_z.append(aoa_irs_z_k)
    aoa_irs_y = np.array(aoa_irs_y)
    aoa_irs_z = np.array(aoa_irs_z)

    # =========bs-user=============
    pathloss_bs_user = np.zeros([num_user, 1])
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_bs)
        pathloss_bs_user_k = path_loss_d(d_k)
        pathloss_bs_user[k, :] = pathloss_bs_user_k

    pathloss = (pathloss_irs_bs, np.array(pathloss_irs_user), np.array(pathloss_bs_user))
    aoa_aod = (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z)
    return pathloss, aoa_aod

def generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs):
    """
    :param location_user: array (num_user,2)
    :param location_bs: array (2,)
    :param location_irs: array (2,)
    :return: pathloss = (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user)
            cos_phi = (cos_phi_1, cos_phi_2, cos_phi_3)
    """
    num_user = location_user.shape[0]
    # =========BS-user=============
    pathloss_BS_user = []
    aoa_BS_y = []
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_bs)
        pathloss_BS_user.append(path_loss_d(d_k))
        aoa_BS_y_k = (location_user[k][0] - location_bs[0]) / d_k
        aoa_BS_y.append(aoa_BS_y_k)
    aoa_BS_y = np.array(aoa_BS_y)

    pathloss = np.array(pathloss_BS_user)
    aoa_aod = aoa_BS_y
    return pathloss, aoa_aod

def generate_pathloss_aoa_aod_MultiBS(location_user, location_bs):
    """
    :param location_user: array (num_user,2)
    :param location_bs: array (2,)
    :param location_irs: array (2,)
    :return: pathloss = (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user)
            cos_phi = (cos_phi_1, cos_phi_2, cos_phi_3)
    """
    num_user = location_user.shape[0]

    # =========bs-user=============
    pathloss_bs_user = np.zeros([num_user, 1])
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_bs)
        pathloss_bs_user_k = path_loss_d(d_k)
        pathloss_bs_user[k, :] = pathloss_bs_user_k

    pathloss =  np.array(pathloss_bs_user)
    return pathloss

def generate_pathloss_aoa_aod_fullRician(location_user, location_bs, location_irs):
    """
    :param location_user: array (num_user,2)
    :param location_bs: array (2,)
    :param location_irs: array (2,)
    :return: pathloss = (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user)
            cos_phi = (cos_phi_1, cos_phi_2, cos_phi_3)
    """
    num_user = location_user.shape[0]
    # ========bs-irs==============
    d0 = np.linalg.norm(location_bs - location_irs)
    pathloss_irs_bs = path_loss_r(d0)
    aoa_bs = ( location_irs[0] - location_bs[0]) / d0
    aod_irs_y = (location_bs[1]-location_irs[1]) / d0
    aod_irs_z = (location_bs[2]-location_irs[2]) / d0
    # =========irs-user=============
    pathloss_irs_user = []
    aoa_irs_y = []
    aoa_irs_z = []
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_irs)
        pathloss_irs_user.append(path_loss_r(d_k))
        aoa_irs_y_k = (location_user[k][1] - location_irs[1]) / d_k
        aoa_irs_z_k = (location_user[k][2] - location_irs[2]) / d_k
        aoa_irs_y.append(aoa_irs_y_k)
        aoa_irs_z.append(aoa_irs_z_k)
    aoa_irs_y = np.array(aoa_irs_y)
    aoa_irs_z = np.array(aoa_irs_z)

    # =========bs-user=============
    aoa_bs_y = []
    aoa_bs_z = []
    pathloss_bs_user = np.zeros([num_user, 1])
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_bs)
        pathloss_bs_user_k = path_loss_d(d_k)
        pathloss_bs_user[k, :] = pathloss_bs_user_k
        aod_bs_k_y = (location_bs[1]-location_user[k]) / d_k                        # changed from ris loc to user loc
        aod_bs_k_z = (location_bs[2]-location_user[k]) / d_k
        aoa_bs_y.append(aod_bs_k_y)
        aoa_bs_z.append(aod_bs_k_z)
    aoa_bs_y = np.array(aoa_bs_y)
    aoa_bs_z = np.array(aoa_bs_z)

    pathloss = (pathloss_irs_bs, np.array(pathloss_irs_user), np.array(pathloss_bs_user))
    aoa_aod = (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z, aoa_bs_y , aoa_bs_z)
    return pathloss, aoa_aod

def generate_pathloss_aoa_aod_2RIS_new(location_user, location_bs, location_irs):
    """
    :param location_user: array (num_user,2)
    :param location_bs: array (2,)
    :param location_irs: array (2,)
    :return: pathloss = (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user)
            cos_phi = (cos_phi_1, cos_phi_2, cos_phi_3)
    """
    num_user = location_user.shape[0]
    # ========bs-irs==============
    d0 = np.linalg.norm(location_bs - location_irs)
    pathloss_irs_bs = path_loss_r(d0)
    aoa_bs =  location_irs[0] / d0  #( location_irs[0] - location_bs[0]) / d0
    aod_irs_y = location_irs[1] / d0  # (location_bs[1]-location_irs[1]) / d0
    aod_irs_z = location_irs[2] / d0 #(location_bs[2]-location_irs[2]) / d0
    # =========irs-user=============
    pathloss_irs_user = []
    aoa_irs_y = []
    aoa_irs_z = []
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_irs)
        pathloss_irs_user.append(path_loss_r(d_k))
        diff_y = location_user[k][1] - location_irs[1]
        diff_x = location_user[k][0] - location_irs[0]
        aoa_irs_y_k = (location_user[k][1] - location_irs[1]) / d_k # (np.arctan(diff_y / diff_x) ) % ( np.pi) # (location_user[k][1] - location_irs[1]) / d_k
        aoa_irs_z_k = ( location_irs[2] -location_user[k][2]) / d_k #np.arcsin( np.sqrt(diff_y**2 + diff_x ** 2)/ d_k) #(location_user[k][2] - location_irs[2]) / d_k
        aoa_irs_y.append(aoa_irs_y_k)
        aoa_irs_z.append(aoa_irs_z_k)
    aoa_irs_y = np.array(aoa_irs_y)
    aoa_irs_z = np.array(aoa_irs_z)

    # =========bs-user=============
    aoa_bs_y = []
    aoa_bs_z = []
    pathloss_bs_user = np.zeros([num_user, 1])
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_bs)
        pathloss_bs_user_k = path_loss_d(d_k)
        pathloss_bs_user[k, :] = pathloss_bs_user_k
        aod_bs_k_y = (location_bs[1]-location_user[k]) / d_k              # changed from ris loc to user loc
        aod_bs_k_z = (location_bs[2]-location_user[k]) / d_k
        aoa_bs_y.append(aod_bs_k_y)
        aoa_bs_z.append(aod_bs_k_z)
    aoa_bs_y = np.array(aoa_bs_y)
    aoa_bs_z = np.array(aoa_bs_z)

    pathloss = (pathloss_irs_bs, np.array(pathloss_irs_user), np.array(pathloss_bs_user))
    aoa_aod = (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z, aoa_bs_y , aoa_bs_z)
    return pathloss, aoa_aod


def generate_pathloss_aoa_aod_fullRician_2RIS(location_user, location_bs, location_irs):
    """
    :param location_user: array (num_user,2)
    :param location_bs: array (2,)
    :param location_irs: array (2,)
    :return: pathloss = (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user)
            cos_phi = (cos_phi_1, cos_phi_2, cos_phi_3)
    """
    num_user = location_user.shape[0]
    # ========bs-irs==============
    d0 = np.linalg.norm(location_bs - location_irs)
    pathloss_irs_bs = path_loss_r(d0)
    oppo = np.sqrt(((location_user[0][0] - location_irs[0]) / d0)**2 + ((location_user[0][1] - location_irs[1]) / d0)**2)
    adj = ( location_irs[2] - location_bs[2]) / d0
    aoa_bs = np.arctan(oppo/adj)
    oppo = (location_bs[0]-location_irs[0]) / d0
    adj = (location_bs[1]-location_irs[1]) / d0
    aod_irs_y =  np.arctan(oppo/adj)
    oppo =  np.sqrt(((location_user[0][0] - location_irs[0]) / d0)**2 + ((location_user[0][1] - location_irs[1]) / d0)**2)
    adj = ( location_irs[2] - location_bs[2]) / d0
    aod_irs_z = np.arctan(oppo/adj)
    # =========irs-user=============
    pathloss_irs_user = []
    aoa_irs_y = []
    aoa_irs_z = []
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_irs)
        pathloss_irs_user.append(path_loss_r(d_k))
        oppo = (location_user[k][0] - location_irs[0]) / d_k
        adj  = (location_user[k][1] - location_irs[1]) / d_k
        hyp = np.sqrt(oppo*oppo + adj*adj)
        aoa_irs_y_k = np.arctan(oppo/adj)
        #aoa_irs_y_k = (location_user[k][1] - location_irs[1]) / d_k
        oppo = hyp
        adj  = (location_user[k][2] - location_irs[2]) / d_k
        aoa_irs_z_k = np.arctan(oppo/adj)
        aoa_irs_y.append(aoa_irs_y_k)
        aoa_irs_z.append(aoa_irs_z_k)
    aoa_irs_y = np.array(aoa_irs_y)
    aoa_irs_z = np.array(aoa_irs_z)

    # =========bs-user=============
    aoa_bs_y = []
    aoa_bs_z = []
    pathloss_bs_user = np.zeros([num_user, 1])
    for k in range(num_user):
        d_k = np.linalg.norm(location_user[k] - location_bs)
        pathloss_bs_user_k = path_loss_d(d_k)
        pathloss_bs_user[k, :] = pathloss_bs_user_k
        oppo =  (location_user[k][2]-location_bs[2]) / d_k
        adj =  np.sqrt(((location_user[k][0] - location_bs[0]) / d_k)**2 + ((location_user[k][1] - location_bs[1]) / d_k)**2)
        aod_bs_k_z = np.arctan(oppo/adj) + np.pi/2
        aoa_bs_z.append(aod_bs_k_z)
    aoa_bs_z = np.array(aoa_bs_z)

    pathloss = (pathloss_irs_bs, np.array(pathloss_irs_user), np.array(pathloss_bs_user))
    aoa_aod = (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z , aoa_bs_z)
    return pathloss, aoa_aod


######################################################################################################################## distance not halfed
def generate_channel(params_system, location_bs=np.array([100, -100, 0]), location_irs=np.array([0, 0, 0]),
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs_irs, channel_bs_user, channel_irs_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)


        pathloss, aoa_aod = generate_pathloss_aoa_aod(location_user, location_bs, location_irs)
        (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user) = pathloss
        (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z) = aoa_aod

        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_irs_bs = pathloss_irs_bs - scale_factor / 2
        pathloss_irs_user = pathloss_irs_user - scale_factor / 2
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        pathloss_irs_user = np.sqrt(10 ** ((-pathloss_irs_user) / 10))
        pathloss_irs_bs = np.sqrt(10 ** ((-pathloss_irs_bs) / 10))

        # tmp:(num_antenna_bs,num_user) channel between BS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        tmp = tmp * pathloss_bs_user.reshape(1, num_user)

        # ######################################################################
        # # some user have LOS, some does not have LOS, make hd equal to 0.

        # user_no_los = random.sample(range(0, num_user), int(np.floor(num_user/3)))
        # tmp[:,user_no_los] = np.zeros([num_antenna_bs,1])
        # #tmp[:,user_no_los] = [0.0000000001]

        # ######################################################################
        channel_bs_user.append(tmp)

        # tmp: (num_antenna_bs,num_elements_irs) channel between IRS and BS
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs])
        a_bs = np.exp(1j * np.pi * aoa_bs * np.arange(num_antenna_bs))
        a_bs = np.reshape(a_bs, [num_antenna_bs, 1])

        i1 = np.mod(np.arange(num_elements_irs),irs_Nh)
        i2 = np.floor(np.arange(num_elements_irs)/irs_Nh)
        a_irs_bs = np.exp(1j * np.pi * (i1*aod_irs_y+i2*aod_irs_z))
        a_irs_bs =  np.reshape(a_irs_bs, [num_elements_irs, 1])
        los_irs_bs = a_bs @ np.transpose(a_irs_bs.conjugate())
        tmp = np.sqrt(Rician_factor / (1 + Rician_factor)) * los_irs_bs + np.sqrt(1/(1 + Rician_factor)) * tmp
        tmp = tmp * pathloss_irs_bs
        channel_bs_irs.append(tmp)

        # tmp:(num_elements_irs,num_user) channel between IRS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user])
        for k in range(num_user):
            a_irs_user = np.exp(1j * np.pi * (i1 * aoa_irs_y[k] + i2 * aoa_irs_z[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_irs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_irs_user[k]
        channel_irs_user.append(tmp)
    channels = (np.array(channel_bs_user), np.array(channel_irs_user), np.array(channel_bs_irs))
    return channels, set_location_user

def generate_channel_fullRician(params_system, location_bs=np.array([100, -100, 0]), location_irs=np.array([0, 0, 0]),
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs_irs, channel_bs_user, channel_irs_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            if location_user_initial.ndim >= 3: # for 2 RIS
                location_user = location_user_initial[ii,:,:]
            else:
                location_user = location_user_initial
            set_location_user.append(location_user)
        pathloss, aoa_aod = generate_pathloss_aoa_aod_fullRician(location_user, location_bs, location_irs)
        (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user) = pathloss
        (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z, aoa_bs_y, aoa_bs_z) = aoa_aod

        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_irs_bs = pathloss_irs_bs - scale_factor / 2
        pathloss_irs_user = pathloss_irs_user - scale_factor / 2
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        pathloss_irs_user = np.sqrt(10 ** ((-pathloss_irs_user) / 10))
        pathloss_irs_bs = np.sqrt(10 ** ((-pathloss_irs_bs) / 10))

        # tmp:(num_antenna_bs,num_user) channel between BS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        i1 = np.arange(1)
        for k in range(num_user):
            a_bs_user = np.exp(1j * np.pi * 0)
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_bs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs_user[k]

        channel_bs_user.append(tmp)

        #################        channel between IRS and BS
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs])
        a_bs = np.exp(1j * np.pi * aoa_bs * np.arange(num_antenna_bs))
        a_bs = np.reshape(a_bs, [num_antenna_bs, 1])

        i1 = np.mod(np.arange(num_elements_irs),irs_Nh)
        i2 = np.floor(np.arange(num_elements_irs)/irs_Nh)
        a_irs_bs = np.exp(1j * np.pi * (i1*aod_irs_y+i2*aod_irs_z))
        a_irs_bs =  np.reshape(a_irs_bs, [num_elements_irs, 1])
        los_irs_bs = a_bs @ np.transpose(a_irs_bs.conjugate())
        tmp = np.sqrt(Rician_factor / (1 + Rician_factor)) * los_irs_bs + np.sqrt(1/(1 + Rician_factor)) * tmp
        tmp = tmp * pathloss_irs_bs
        channel_bs_irs.append(tmp)

        ###############         channel between IRS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user])
        for k in range(num_user):
            a_irs_user = np.exp(1j * np.pi * (i1 * aoa_irs_y[k] + i2 * aoa_irs_z[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_irs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_irs_user[k]
        channel_irs_user.append(tmp)
    channels = (np.array(channel_bs_user), np.array(channel_irs_user), np.array(channel_bs_irs))
    return channels, set_location_user


def generate_channel_fullRician_2RIS(params_system,location_bs, location_irs1,
                    location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs_irs, channel_bs_user, channel_irs_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)
        pathloss_2RIS, aoa_aod_2RIS = generate_pathloss_aoa_aod_2RIS_new(location_user, location_bs, location_irs1)
        (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user) = pathloss_2RIS
        (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z, aoa_bs_y, aoa_bs_z) = aoa_aod_2RIS

        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_irs_bs = pathloss_irs_bs - scale_factor / 2
        pathloss_irs_user = pathloss_irs_user - scale_factor / 2
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        pathloss_irs_user = np.sqrt(10 ** ((-pathloss_irs_user) / 10))
        pathloss_irs_bs = np.sqrt(10 ** ((-pathloss_irs_bs) / 10))

        # tmp:(num_antenna_bs,num_user) channel between BS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])

        for k in range(num_user):
            #a_bs_user = np.exp(1j * np.pi * a_bs)
            a_bs_user = np.exp(1j * np.pi * aoa_bs_z * np.arange(num_antenna_bs))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_bs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs_user[k]

        channel_bs_user.append(tmp)

        #################        channel between IRS and BS
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs])
        a_bs = np.exp(1j * np.pi * aoa_bs * np.arange(num_antenna_bs))
        a_bs = np.reshape(a_bs, [num_antenna_bs, 1])

        i1 = np.mod(np.arange(num_elements_irs),irs_Nh)
        i2 = np.floor(np.arange(num_elements_irs)/irs_Nh)
        a_irs_bs = np.exp(1j * np.pi * (i1*aod_irs_y+i2*aod_irs_z))
        a_irs_bs =  np.reshape(a_irs_bs, [num_elements_irs, 1])
        los_irs_bs = a_bs @ np.transpose(a_irs_bs.conjugate())
        tmp = np.sqrt(Rician_factor / (1 + Rician_factor)) * los_irs_bs + np.sqrt(1/(1 + Rician_factor)) * tmp
        tmp = tmp * pathloss_irs_bs
        channel_bs_irs.append(tmp)

        ###############         channel between IRS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user])
        for k in range(num_user):
            a_irs_user = np.exp(1j * np.pi * (i1 * aoa_irs_y[k] + i2 * aoa_irs_z[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_irs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_irs_user[k]
        channel_irs_user.append(tmp)
    channels = (np.array(channel_bs_user), np.array(channel_irs_user), np.array(channel_bs_irs))
    return channels, set_location_user




def generate_channel_fullRician_radiomap(params_system, location_bs=np.array([100, -100, 0]), location_irs=np.array([0, 0, 0]),
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs_irs, channel_bs_user, channel_irs_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)
        pathloss, aoa_aod = generate_pathloss_aoa_aod_fullRician(location_user, location_bs, location_irs)
        (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user) = pathloss
        (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z, aoa_bs_y, aoa_bs_z) = aoa_aod

        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_irs_bs = pathloss_irs_bs - scale_factor / 2
        pathloss_irs_user = pathloss_irs_user - scale_factor / 2
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        pathloss_irs_user = np.sqrt(10 ** ((-pathloss_irs_user) / 10))
        pathloss_irs_bs = np.sqrt(10 ** ((-pathloss_irs_bs) / 10))

        # tmp:(num_antenna_bs,num_user) channel between BS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        i1 = np.arange(1)
        for k in range(num_user):
            a_bs_user = np.exp(1j * np.pi * 0)
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_bs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs_user[k]

        channel_bs_user.append(tmp)

        #################        channel between IRS and BS
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs])
        a_bs = np.exp(1j * np.pi * aoa_bs * np.arange(num_antenna_bs))
        a_bs = np.reshape(a_bs, [num_antenna_bs, 1])

        i1 = np.mod(np.arange(num_elements_irs),irs_Nh)
        i2 = np.floor(np.arange(num_elements_irs)/irs_Nh)
        a_irs_bs = np.exp(1j * np.pi * (i1*aod_irs_y+i2*aod_irs_z))
        a_irs_bs =  np.reshape(a_irs_bs, [num_elements_irs, 1])
        los_irs_bs = a_bs @ np.transpose(a_irs_bs.conjugate())
        tmp = np.sqrt(Rician_factor / (1 + Rician_factor)) * los_irs_bs + np.sqrt(1/(1 + Rician_factor)) * tmp
        tmp = tmp * pathloss_irs_bs
        channel_bs_irs.append(tmp)

        ###############         channel between IRS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user])
        for k in range(num_user):
            a_irs_user = np.exp(1j * np.pi * (i1 * aoa_irs_y[k] + i2 * aoa_irs_z[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_irs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_irs_user[k]
        channel_irs_user.append(tmp)
    channels = (np.array(channel_bs_user), np.array(channel_irs_user), np.array(channel_bs_irs))
    return channels, set_location_user

def generate_channel_MultiBS_rician(params_system, location_bs1,location_bs2,location_bs3,
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs1_user,channel_bs2_user,channel_bs3_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)

        pathloss_bs1_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs1)
        aoa_BS1 = aoa_aod
        pathloss_bs2_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs2)
        aoa_BS2 = aoa_aod
        pathloss_bs3_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs3)
        aoa_BS3 = aoa_aod

        pathloss_bs1_user = pathloss_bs1_user - scale_factor
        pathloss_bs1_user = np.sqrt(10 ** ((-pathloss_bs1_user) / 10))
        pathloss_bs2_user = pathloss_bs2_user - scale_factor
        pathloss_bs2_user = np.sqrt(10 ** ((-pathloss_bs2_user) / 10))
        pathloss_bs3_user = pathloss_bs3_user - scale_factor
        pathloss_bs3_user = np.sqrt(10 ** ((-pathloss_bs3_user) / 10))

        # tmp:(num_elements_irs,num_user) channel between IRS and user
        i1 = np.arange(num_antenna_bs)
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        for k in range(num_user):
            a_BS1_user = np.exp(1j * np.pi * (i1 * aoa_BS1[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS1_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs1_user[k]
        channel_bs1_user.append(tmp)

        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        for k in range(num_user):
            a_BS2_user = np.exp(1j * np.pi * (i1 * aoa_BS2[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS2_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs2_user[k]
        channel_bs2_user.append(tmp)

        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        for k in range(num_user):
            a_BS3_user = np.exp(1j * np.pi * (i1 * aoa_BS3[k] ))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS3_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs3_user[k]
        channel_bs3_user.append(tmp)

    channels = (np.array(channel_bs1_user), np.array(channel_bs2_user), np.array(channel_bs3_user))
    return channels, set_location_user


def generate_channel_MultiBS_1_plus_2BS_rician(params_system, location_bs1,location_bs2,location_bs3,
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (N_main, N_secondary, num_user) = params_system

    channel_bs1_user,channel_bs2_user,channel_bs3_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)

        pathloss_bs1_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs1)
        aoa_BS1 = aoa_aod
        pathloss_bs2_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs2)
        aoa_BS2 = aoa_aod
        pathloss_bs3_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs3)
        aoa_BS3 = aoa_aod

        pathloss_bs1_user = pathloss_bs1_user - scale_factor
        pathloss_bs1_user = np.sqrt(10 ** ((-pathloss_bs1_user) / 10))
        pathloss_bs2_user = pathloss_bs2_user - scale_factor
        pathloss_bs2_user = np.sqrt(10 ** ((-pathloss_bs2_user) / 10))
        pathloss_bs3_user = pathloss_bs3_user - scale_factor
        pathloss_bs3_user = np.sqrt(10 ** ((-pathloss_bs3_user) / 10))

        # tmp:(num_elements_irs,num_user) channel between IRS and user
        i1 = np.arange(N_main)
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_main, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_main, num_user])
        for k in range(num_user):
            a_BS1_user = np.exp(1j * np.pi * 0)
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS1_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs1_user[k]
        channel_bs1_user.append(tmp)

        i1 = np.arange(N_secondary)
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_secondary, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_secondary, num_user])
        for k in range(num_user):
            a_BS2_user = np.exp(1j * np.pi * (i1 * aoa_BS2[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS2_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs2_user[k]
        channel_bs2_user.append(tmp)

        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_secondary, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_secondary, num_user])
        for k in range(num_user):
            a_BS3_user = np.exp(1j * np.pi * (i1 * aoa_BS3[k] ))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS3_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs3_user[k]
        channel_bs3_user.append(tmp)

    channels = (np.array(channel_bs1_user), np.array(channel_bs2_user), np.array(channel_bs3_user))
    return channels, set_location_user


def generate_channel_MultiBS_main_secondary_rician(params_system, location_bs_main,location_bs2_secondary=np.array([0, 0, 0]),
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (N_main, N_secondary, num_user) = params_system

    channel_bs1_user,channel_bs2_user, set_location_user = [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)

        pathloss_bs1_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs_main)
        aoa_BS1 = aoa_aod
        pathloss_bs2_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs2_secondary)
        aoa_BS2 = aoa_aod

        pathloss_bs1_user = pathloss_bs1_user - scale_factor
        pathloss_bs1_user = np.sqrt(10 ** ((-pathloss_bs1_user) / 10))
        pathloss_bs2_user = pathloss_bs2_user - scale_factor
        pathloss_bs2_user = np.sqrt(10 ** ((-pathloss_bs2_user) / 10))

        # tmp:(num_elements_irs,num_user) channel between IRS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_main, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_main, num_user])
        for k in range(num_user):
            a_BS1_user = np.exp(1j * np.pi * 0)
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS1_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs1_user[k]
        channel_bs1_user.append(tmp)

        i1 = np.arange(N_secondary)
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_secondary, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[N_secondary, num_user])
        for k in range(num_user):
            a_BS2_user = np.exp(1j * np.pi * (i1 * aoa_BS2[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS2_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs2_user[k]
        channel_bs2_user.append(tmp)

    channels = (np.array(channel_bs1_user), np.array(channel_bs2_user))
    return channels, set_location_user

def generate_channel_singleBS_rician(params_system, location_bs=np.array([100, -100, 0]),
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs1_user,channel_bs2_user,channel_bs3_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)

        pathloss_bs1_user, aoa_aod = generate_pathloss_aoa_aod_MultiBS_rician(location_user, location_bs)
        (aoa_BS1_y, aoa_BS1_z) = aoa_aod

        pathloss_bs1_user = pathloss_bs1_user - scale_factor
        pathloss_bs1_user = np.sqrt(10 ** ((-pathloss_bs1_user) / 10))

        # tmp:(num_elements_irs,num_user) channel between IRS and user
        i1 = np.arange(num_antenna_bs)
        i2 = np.arange(1)
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        for k in range(num_user):
            a_BS1_user = np.exp(1j * np.pi * (i1 * aoa_BS1_y[k] + i2 * aoa_BS1_z[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_BS1_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_bs1_user[k]
        channel_bs1_user.append(tmp)

    return np.array(channel_bs1_user), set_location_user

def generate_channel_MultiBS(params_system, location_bs1,location_bs2,location_bs3,
                        location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs1_user,channel_bs2_user,channel_bs3_user, set_location_user = [],[],[], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)

        # ######### BS 1
        pathloss_bs_user = generate_pathloss_aoa_aod_MultiBS(location_user, location_bs1)
        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        tmp = tmp * pathloss_bs_user.reshape(1, num_user)
        channel_bs1_user.append(tmp)

        # ######### BS 2
        pathloss_bs_user = generate_pathloss_aoa_aod_MultiBS(location_user, location_bs2)
        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        tmp = tmp * pathloss_bs_user.reshape(1, num_user)
        channel_bs2_user.append(tmp)

        # ######### BS 3
        pathloss_bs_user = generate_pathloss_aoa_aod_MultiBS(location_user, location_bs3)
        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        tmp = tmp * pathloss_bs_user.reshape(1, num_user)
        channel_bs3_user.append(tmp)

    channels = (np.array(channel_bs1_user),np.array(channel_bs2_user) ,np.array(channel_bs3_user))
    return channels, set_location_user

def generate_channel_debug(params_system, location_bs=np.array([100, -100, 0]), location_irs=np.array([0, 0, 0]),
                     location_user_initial=None, Rician_factor=10, scale_factor=100, num_samples=100,irs_Nh = 16):
    # scale_factor: can be viewed as (downlink noise_power_dB- downlink Pt)

    (num_antenna_bs, num_elements_irs, num_user) = params_system

    channel_bs_irs, channel_bs_user, channel_irs_user, set_location_user = [], [], [], []
    for ii in range(num_samples):
        if location_user_initial is None:
            location_user = generate_location(num_user)
            set_location_user.append(location_user)
        else:
            location_user = location_user_initial
            set_location_user.append(location_user)

        pathloss, aoa_aod = generate_pathloss_aoa_aod(location_user, location_bs, location_irs)
        (pathloss_irs_bs, pathloss_irs_user, pathloss_bs_user) = pathloss
        (aoa_bs, aod_irs_y, aod_irs_z, aoa_irs_y, aoa_irs_z) = aoa_aod

        pathloss_bs_user = pathloss_bs_user - scale_factor
        pathloss_irs_bs = pathloss_irs_bs - scale_factor / 2
        pathloss_irs_user = pathloss_irs_user - scale_factor / 2
        pathloss_bs_user = np.sqrt(10 ** ((-pathloss_bs_user) / 10))
        pathloss_irs_user = np.sqrt(10 ** ((-pathloss_irs_user) / 10))
        pathloss_irs_bs = np.sqrt(10 ** ((-pathloss_irs_bs) / 10))

        # tmp:(num_antenna_bs,num_user) channel between BS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_user])
        tmp = tmp * pathloss_bs_user.reshape(1, num_user)

        channel_bs_user.append(tmp)

        # tmp: (num_antenna_bs,num_elements_irs) channel between IRS and BS
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_antenna_bs, num_elements_irs])
        a_bs = np.exp(1j * np.pi * aoa_bs * np.arange(num_antenna_bs))
        a_bs = np.reshape(a_bs, [num_antenna_bs, 1])

        i1 = np.mod(np.arange(num_elements_irs),irs_Nh)
        i2 = np.floor(np.arange(num_elements_irs)/irs_Nh)
        a_irs_bs = np.exp(1j * np.pi * (i1*aod_irs_y+i2*aod_irs_z))
        a_irs_bs =  np.reshape(a_irs_bs, [num_elements_irs, 1])
        los_irs_bs = a_bs @ np.transpose(a_irs_bs.conjugate())
        tmp = np.sqrt(Rician_factor / (1 + Rician_factor)) * los_irs_bs + np.sqrt(1/(1 + Rician_factor)) * tmp
        tmp = tmp * pathloss_irs_bs
        channel_bs_irs.append(tmp)

        # tmp:(num_elements_irs,num_user) channel between IRS and user
        tmp = np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user]) \
              + 1j * np.random.normal(loc=0, scale=np.sqrt(0.5), size=[num_elements_irs, num_user])
        for k in range(num_user):
            a_irs_user = np.exp(1j * np.pi * (i1 * aoa_irs_y[k] + i2 * aoa_irs_z[k]))
            tmp[:, k] = np.sqrt(Rician_factor/(1+Rician_factor))*a_irs_user+np.sqrt(1/(1+Rician_factor))*tmp[:, k]
            tmp[:, k] = tmp[:, k] * pathloss_irs_user[k]
        channel_irs_user.append(tmp)
    channels = (np.array(channel_bs_user), np.array(channel_irs_user), np.array(channel_bs_irs))
    print(aoa_irs_z)
    print(aoa_irs_y)
    angle_ele = math.asin(aoa_irs_z)
    angle_az = math.asin(aoa_irs_y / math.cos(angle_ele))
    angles = (angle_ele , angle_az)
    return channels, set_location_user, angles


def channel_complex2real(channels):
    channel_bs_user, channel_irs_user, channel_bs_irs = channels
    (num_sample, num_antenna_bs, num_elements_irs) = channel_bs_irs.shape
    num_user = channel_irs_user.shape[2]

    A_T_real = np.zeros([num_sample, 2 * num_elements_irs, 2 * num_antenna_bs, num_user])
    # Hd_real = np.zeros([num_sample, 2 * num_antenna_bs, num_user])
    set_channel_combine_irs = np.zeros([num_sample, num_antenna_bs, num_elements_irs, num_user], dtype=complex)

    for kk in range(num_user):
        channel_irs_user_k = channel_irs_user[:, :, kk]
        channel_combine_irs = channel_bs_irs * channel_irs_user_k.reshape(num_sample, 1, num_elements_irs)
        set_channel_combine_irs[:, :, :, kk] = channel_combine_irs
        A_tmp_tran = np.transpose(channel_combine_irs, (0, 2, 1))
        A_tmp_real1 = np.concatenate([A_tmp_tran.real, A_tmp_tran.imag], axis=2)
        A_tmp_real2 = np.concatenate([-A_tmp_tran.imag, A_tmp_tran.real], axis=2)
        A_tmp_real = np.concatenate([A_tmp_real1, A_tmp_real2], axis=1)
        A_T_real[:, :, :, kk] = A_tmp_real

    Hd_real = np.concatenate([channel_bs_user.real, channel_bs_user.imag], axis=1)

    return A_T_real, Hd_real, np.array(set_channel_combine_irs)

# Commented out IPython magic to ensure Python compatibility.
import tensorflow.compat.v1 as tf
tf.disable_v2_behavior()
import numpy as np
import matplotlib.pyplot as plt
import scipy.io as sio
#import keras.layers.normalization
from tensorflow.keras.layers import BatchNormalization
from keras.layers import Dense
#from wsr.bcd.generate_received_pilots import generate_received_pilots_batch
import datetime
# %load_ext tensorboard
#!rm -rf ./logs/

# these three lines are needed if using google colab, otherwise can delete
from google.colab import drive
drive.mount('/content/drive')
drive_save_path = '/content/drive/MyDrive/ris_localization_2D_fixedi1/RNN/codebook'

'System Information'
N = 1   #Number of BS's antennas
delta_inv = 1
#Number of posterior intervals inputed to DNN
delta = 1/delta_inv
S = np.log2(delta_inv)
OS_rate = 20 #Over sampling rate in each AoA interval (N_s in the paper)
delta_inv_OS = OS_rate*delta_inv #Total number of AoAs for posterior computation
delta_OS = 1/delta_inv_OS
'Channel Information'
phi_min = -60*(np.pi/180) #Lower-bound of AoAs
phi_max = 60*(np.pi/180) #Upper-bound of AoAs
num_SNR = 8 #Number of considered SNRs
x_lowerlimit, x_upperlimit = -35, -5
y_lowerlimit, y_upperlimit = 5, 75
z_fixed = -20
x_diff, y_diff = x_upperlimit - x_lowerlimit + 1, y_upperlimit -y_lowerlimit+1

#location_bs_new = np.array([40, -40, 0])
location_bs_new = np.array([0, 0, 0])
location_ris_1 = np.array([-40, 40, 10])
commitment_cost = 0.25

codebooksize = 10000

tau =  14 #Pilot length
snr_const = 25 #The SNR
snr_const = np.array([snr_const])
Pvec = 10**(snr_const/10) #Set of considered TX powers


mean_true_alpha = 0.0 + 0.0j #Mean of the fading coefficient
std_per_dim_alpha = np.sqrt(0.5) #STD of the Gaussian fading coefficient per real dim.
noiseSTD_per_dim = np.sqrt(0.5) #STD of the Gaussian noise per real dim.
#####################################################
'RIS'
N_ris = 64
num_users = 1
params_system = (N,N_ris,num_users)
Rician_factor = 10
location_user = None

#####################################################
'Learning Parameters'
initial_run = 0    #0: Continue training; 1: Starts from the scratch
if initial_run == 1:
  print('!!!!! training from scratch !!!!!')
n_epochs = 15000 #Num of epochs
learning_rate = 0.00005 #Learning rate
batch_per_epoch = 200 #Number of mini batches per epoch
batch_size_order = 8 #Mini_batch_size = batch_size_order*delta_inv
val_size_order = 100 #Validation_set_size = val_size_order*delta_inv
scale_factor = 1 #Scaling the number of tests
test_size_order = 200 #Test_set_size = test_size_order*delta_inv*scale_factor
######################################################
tf.reset_default_graph() #Reseting the graph
he_init = tf.variance_scaling_initializer() #Define initialization method
######################################## Place Holders
#alpha_input = tf.placeholder(tf.float32, shape=(None,1), name="alpha_input")
loc_input = tf.placeholder(tf.float32, shape=(None,1,3), name="loc_input")
channel_bs_irs_user = tf.placeholder(tf.float32, shape=(None, 2 * N_ris, 2 * N, num_users), name="channel_bs_irs_user")
channel_bs_user = tf.placeholder(tf.float32, shape=(None, 2 * N, num_users), name="channel_bs_irs_user")
######################################################

def generate_RSS_adaptive(A_T_real, the_theta, P_temp):
    RSS_list = np.zeros((tau), dtype=float)
    for tau_i in range(tau):
        theta_i = the_theta[[tau_i], :]
        theta = np.concatenate([theta_i.real, theta_i.imag], axis=1)
        theta_T = np.reshape(theta, [-1, 1, 2 * N_ris])
        A_T_k = A_T_real[0, :, :, 0]
        theta_A_k_T = np.matmul(theta_T, A_T_k)
        theta_A_k_T_re = theta_A_k_T[:,:,0]
        theta_A_k_T_im = theta_A_k_T[:,:,1]
        RSS_i =  abs( (np.sqrt(P_temp)+ 1j*0.0) *(theta_A_k_T_re + 1j*theta_A_k_T_im)) ** 2

        RSS_list[tau_i] = RSS_i

    return RSS_list

def generate_radio_map(theta_test, x_range, y_range, z_fixed):
    radio_map = np.zeros([x_range,y_range,tau])

    for x_i in range(x_range):
        for y_i in range(y_range):
            coordinate_k = np.array([x_i + x_lowerlimit, y_i + y_lowerlimit, z_fixed])
            # generage channel/fingerprint based on location
            location_user = np.empty([num_users, 3])
            location_user[0, :] = coordinate_k
            channel_true, set_location_user_train = generate_channel_fullRician(params_system, location_bs_new,location_ris_1,
                                                        num_samples= 1 ,
                                                       location_user_initial=location_user, Rician_factor=Rician_factor)
            A_T_real, Hd_real_train , _ = channel_complex2real(channel_true)
            RSS_offline = generate_RSS_adaptive(A_T_real, theta_test ,Pvec[0])

            radio_map[x_i, y_i, :] = RSS_offline
    return radio_map, theta_test

######################################################
#Constructing the array responses for AoA samples
##################### NETWORK
with tf.name_scope("array_response_construction"):
    lay = {}
    lay['P'] = tf.constant(1.0)
    ###############
    from0toN = tf.cast(tf.range(0, N, 1),tf.float32)

with tf.name_scope("channel_sensing"):
    hidden_size = 512
    A1 = tf.get_variable("A1",  shape=[hidden_size,1024], dtype=tf.float32, initializer= he_init)
    A2 = tf.get_variable("A2",  shape=[1024,1024], dtype=tf.float32, initializer= he_init)
    A3 = tf.get_variable("A3",  shape=[1024,1024], dtype=tf.float32, initializer= he_init)
    A4 = tf.get_variable("A4",  shape=[1024,2*N_ris], dtype=tf.float32, initializer= he_init)

    b1 = tf.get_variable("b1",  shape=[1024], dtype=tf.float32, initializer= he_init)
    b2 = tf.get_variable("b2",  shape=[1024], dtype=tf.float32, initializer= he_init)
    b3 = tf.get_variable("b3",  shape=[1024], dtype=tf.float32, initializer= he_init)
    b4 = tf.get_variable("b4",  shape=[2*N_ris], dtype=tf.float32, initializer= he_init)

    emb_vq = tf.get_variable(name='embedding_vq', shape=[codebooksize, 2*N_ris], initializer=tf.uniform_unit_scaling_initializer())
    perplexity_list = []

    w_dict = []
    posterior_dict = []
    idx_est_dict = []
    layer_Ui = Dense(units=hidden_size, activation='linear')
    layer_Wi = Dense(units=hidden_size, activation='linear')
    layer_Uf = Dense(units=hidden_size, activation='linear')
    layer_Wf = Dense(units=hidden_size, activation='linear')
    layer_Uo = Dense(units=hidden_size, activation='linear')
    layer_Wo = Dense(units=hidden_size, activation='linear')
    layer_Uc = Dense(units=hidden_size, activation='linear')
    layer_Wc = Dense(units=hidden_size, activation='linear')
    def RNN(input_x, h_old, c_old):
        i_t = tf.sigmoid(layer_Ui(input_x) + layer_Wi(h_old))
        f_t = tf.sigmoid(layer_Uf(input_x) + layer_Wf(h_old))
        o_t = tf.sigmoid(layer_Uo(input_x) + layer_Wo(h_old))
        c_t = tf.tanh(layer_Uc(input_x) + layer_Wc(h_old))
        c = i_t * c_t + f_t * c_old     # cell state
        h_new = o_t * tf.tanh(c)        # hidden state
        return h_new, c

    snr = lay['P']*tf.ones(shape=[tf.shape(loc_input)[0],1],dtype=tf.float32)
    snr_dB = tf.log(snr)/np.log(10)
    snr_normal = (snr_dB-1)/np.sqrt(1.6666) #Normalizing for the range -10dB to 30dB
    theta_list = []
    theta_list_knn = []
    loss_VQ = 0

    for t in range(tau):
        'DNN designs the next sensing direction'
        if t == 0:
            y_real = tf.ones([tf.shape(loc_input)[0],2])
            h_old = tf.zeros([tf.shape(loc_input)[0],hidden_size])
            c_old = tf.zeros([tf.shape(loc_input)[0],hidden_size])
        h_old, c_old = RNN(tf.concat([y_real,snr_normal],axis=1), h_old, c_old)

        x1 = tf.nn.relu(h_old@A1+b1)
        x1 = BatchNormalization()(x1)
        x2 = tf.nn.relu(x1@A2+b2)
        x2 = BatchNormalization()(x2)
        x3 = tf.nn.relu(x2@A3+b3)
        x3 = BatchNormalization()(x3)
        '''
            RIS implementation
        '''
        ris_her_unnorm = x3 @ A4 + b4
        ris_her_r = ris_her_unnorm[:, 0:N_ris]
        ris_her_i = ris_her_unnorm[:, N_ris:2 * N_ris]                      # (? , N_ris)
        theta_tmp = tf.sqrt(tf.square(ris_her_r) + tf.square(ris_her_i))    # (? , N_ris)
        theta_real = ris_her_r / theta_tmp                                  # (? , N_ris)
        theta_imag = ris_her_i / theta_tmp                                  # (? , N_ris)
        theta = tf.concat([theta_real, theta_imag], axis=1)                 # (? , 2*N_ris)
        theta_T = tf.reshape(theta, [-1, 1, 2 * N_ris])                     # (? , 1 , 2 * N_ris)

        'VQVAE '

        #tf.summary.histogram("theta_T_RNN", theta_T)

        emb_vq_r = emb_vq[:, 0:N_ris]
        emb_vq_i = emb_vq[:, N_ris:2 * N_ris]
        emb_vq_tmp = tf.sqrt(tf.square(emb_vq_r) + tf.square(emb_vq_i))    # (? , N_ris)
        emb_vq_r = emb_vq_r / emb_vq_tmp                                  # (? , N_ris)
        emb_vq_i = emb_vq_i / emb_vq_tmp                                  # (? , N_ris)
        emb_vq_normed = tf.concat([emb_vq_r, emb_vq_i], axis=1)                 # (? , 2*N_ris)

        distances =  tf.reduce_sum(tf.abs(tf.subtract(emb_vq_normed, theta_T)), 2)
        neg_one = tf.constant(-1.0, dtype=tf.float32)
        neg_distances = tf.multiply(distances, neg_one)
        vals, indx = tf.nn.top_k(neg_distances, 1)  # find one neighbor
        encodings = tf.one_hot(indx[:,0], codebooksize)
        avg_probs = tf.reduce_mean(encodings, 0) # ( 10k, )
        perplexity = tf.exp(- tf.reduce_sum(avg_probs * tf.log(avg_probs+1e-10))) # ()
        perplexity_list.append(perplexity)

        quantized = tf.nn.embedding_lookup(emb_vq, indx)

        inp_latent_loss = tf.reduce_mean((tf.stop_gradient(quantized) - theta_T)**2)
        emb_latent_loss = tf.reduce_mean((quantized - tf.stop_gradient(theta_T))**2)
        loss_VQ  += emb_latent_loss + commitment_cost*inp_latent_loss # used to optimize emb_vq only!

        quantized = theta_T + tf.stop_gradient(quantized-theta_T)
        theta_T_quantized = quantized
        #print(quantized.shape)

        theta_list.append(theta_T[:,0,:])
        theta_list_knn.append(theta_T_quantized[:,0,:])


        'BS observes the next measurement'

        A_T_k = channel_bs_irs_user[:, :, :, 0] # since 1 user
        theta_A_k_T = tf.matmul(theta_T_quantized, A_T_k)                             # (? , 1 , 2 * N )

        h_d = channel_bs_user[:,:,0]
        h_d_T = tf.reshape(h_d, [-1, 1, 2 * N])

        h_d_plus_h_cas = h_d_T + theta_A_k_T
        h_d_plus_h_cas_re = h_d_plus_h_cas[:,:,0]
        h_d_plus_h_cas_im = h_d_plus_h_cas[:,:,1]
        noise =  tf.complex(tf.random_normal(tf.shape(h_d_plus_h_cas_re), mean = 0.0, stddev = noiseSTD_per_dim),\
                    tf.random_normal(tf.shape(h_d_plus_h_cas_re), mean = 0.0, stddev = noiseSTD_per_dim))
        y_complex = tf.complex(tf.sqrt(lay['P']),0.0)*tf.complex(h_d_plus_h_cas_re,h_d_plus_h_cas_im) + noise
        y_real = tf.concat([tf.real(y_complex),tf.imag(y_complex)],axis=1)/tf.sqrt(lay['P'])

    h_old, c_old = RNN(tf.concat([y_real,snr_normal],axis=1), h_old, c_old)

    c_old = Dense(units=200, activation='linear')(c_old)
    c_old = Dense(units=200, activation='linear')(c_old)
    c_old = Dense(units=200, activation='linear')(c_old)
    loc_hat = Dense(units=3, activation='linear')(c_old)

####################################################################################
####### Loss Function
a = tf.math.reduce_euclidean_norm(loc_input[:,0,:]-loc_input[:,0,:], 1)
b = tf.math.reduce_euclidean_norm(loc_hat-loc_input[:,0,:], 1)
loss_MSE = tf.keras.losses.mean_squared_error(a, b)
loss = loss_MSE + loss_VQ
print(loss)
####### Optimizer
optimizer = tf.train.AdamOptimizer(learning_rate)
training_op = optimizer.minimize(loss, name="training_op")
init = tf.global_variables_initializer()
saver = tf.train.Saver()
#########################################################################
###########  Validation Set
channel_true_val, set_location_user_val = generate_channel_fullRician(params_system,  location_bs_new, location_ris_1,
                                                        num_samples=val_size_order*delta_inv, location_user_initial=location_user, Rician_factor=Rician_factor)
(channel_bs_user_val, channel_irs_user_val, channel_bs_irs_val) = channel_true_val
A_T_real_val, Hd_real_val , channel_bs_irs_user_val = channel_complex2real(channel_true_val)

feed_dict_val = {loc_input: np.array(set_location_user_val),
                    channel_bs_irs_user: A_T_real_val,
                    channel_bs_user : Hd_real_val,
                    lay['P']: Pvec[0]}
###########  Training
with tf.Session() as sess:
    if initial_run == 1:
        init.run()
    else:
        saver.restore(sess, drive_save_path + '/param/params_RNNselect_v27_VQVAE_newcoordinateSISO_N_'+str(N_ris)+'_size_'+str(codebooksize)+'_tau_'+ str(tau) +'_snr_'+ str(snr_const[0]))
    best_loss, pp = sess.run([loss,posterior_dict], feed_dict=feed_dict_val)
    print(best_loss)
    print(tf.test.is_gpu_available()) #Prints whether or not GPU is on



    counter = 0
    for epoch in range(n_epochs):
        batch_iter = 0
        for rnd_indices in range(batch_per_epoch):

            counter += 1
            snr_temp = snr_const[0]
            P_temp = 10**(snr_temp/10)

            '''
                RIS implementation
            '''
            channel_true_train, set_location_user_train = generate_channel_fullRician(params_system, location_bs_new,location_ris_1,
                                                        num_samples=batch_size_order*delta_inv,
                                                       location_user_initial=location_user, Rician_factor=Rician_factor)
            (channel_bs_user_train, channel_irs_user_train, channel_bs_irs_train) = channel_true_train
            A_T_real, Hd_real_train , channel_bs_irs_user_train = channel_complex2real(channel_true_train)


            feed_dict_batch = {loc_input: np.array(set_location_user_train),
                              channel_bs_irs_user: A_T_real,
                               channel_bs_user : Hd_real_train,
                              lay['P']: P_temp}
            sess.run(training_op, feed_dict=feed_dict_batch)


            batch_iter += 1



        loss_val,loss_MSE_val = sess.run([loss, loss_MSE], feed_dict=feed_dict_val)
        print('epoch',epoch,'  loss_test:%2.5f'%loss_val,'  best_test:%2.5f. '%best_loss, '  MSE loss: %2.5f'%loss_MSE_val)
        if epoch%10 == 9: #Every 10 iterations it checks if the validation performace is improved, then saves parameters
            if loss_val < best_loss:
                save_path = saver.save(sess, drive_save_path+'/param/params_RNNselect_v27_VQVAE_newcoordinateSISO_N_'+str(N_ris)+'_size_'+str(codebooksize)+'_tau_'+ str(tau) +'_snr_'+ str(snr_const[0]))
                best_loss = loss_val

###########  Final Test
    performance = np.zeros([1,scale_factor])
    for j in range(scale_factor):
        print(j)

        channel_true_test, set_location_user_test = generate_channel_fullRician(params_system, location_bs_new, location_ris_1,
                                                        num_samples=test_size_order*delta_inv,
                                                       location_user_initial=location_user, Rician_factor=Rician_factor)
        (channel_bs_user_test, channel_irs_user_test, channel_bs_irs_test) = channel_true_test
        A_T_real_test, Hd_real_test , channel_bs_irs_user_test = channel_complex2real(channel_true_test)
        #theta_library_real_test = np.repeat(theta_library_real, val_size_order*delta_inv, axis = 0)

        feed_dict_test = {loc_input: np.array(set_location_user_test),
                            channel_bs_irs_user: A_T_real_test,
                            channel_bs_user : Hd_real_test,
                            lay['P']: Pvec[0]}

        mse_loss,phi_hat_test= sess.run([loss,loc_hat],feed_dict=feed_dict_test)
        performance[0,j] = mse_loss

    performance = np.mean(performance,axis=1)


###########  Final Test
    for j in range(1):
        print(j)
        location_user_target = np.empty([num_users, 3])
        coordinate_k = np.array([-10 , 40, -20])

        #coordinate_k = np.array([-10 , 20, -20])
        location_user_target[0, :] = coordinate_k

        channel_true_test, set_location_user_test = generate_channel_fullRician(params_system, location_bs_new,location_ris_1,
                                                        num_samples=1,
                                                       location_user_initial=location_user_target, Rician_factor=Rician_factor)
        A_T_1_real_test, Hd_real_test , channel_bs_irs_user_test = channel_complex2real(channel_true_test)

        feed_dict_test = {loc_input: np.array(set_location_user_test),
                            channel_bs_irs_user: A_T_1_real_test,
                            channel_bs_user : Hd_real_test,
                            lay['P']: Pvec[0]}
        loss_MSE_test,phi_hat_test,perplexity_list_test, theta_test, theta_test_knn = \
                  sess.run([loss_MSE,loc_hat,perplexity_list,theta_list,theta_list_knn],feed_dict=feed_dict_test)


        theta_test = np.array(theta_test)
        theta_test = theta_test[:,0,0:N_ris] + 1j* theta_test[:,0,N_ris:2*N_ris]
        radio_map, theta_test = generate_radio_map(theta_test, x_diff, y_diff, z_fixed)

        theta_test_knn = np.array(theta_test_knn)
        theta_test_knn = theta_test_knn[:,0,0:N_ris] + 1j* theta_test_knn[:,0,N_ris:2*N_ris]
        radio_map_knn, theta_test_knn = generate_radio_map(theta_test_knn, x_diff, y_diff, z_fixed)


sio.savemat(drive_save_path + '/interp/interp_VQVAE_N_' +str(N_ris)+'_size_'+str(codebooksize)+'_tau_'+ str(tau) +'_snr_'+ str(snr_const[0]) + '.mat',dict(snr_const=snr_const,\
                                    N=N,N_ris = N_ris,epoch = n_epochs,delta_inv=delta_inv,\
                                    mean_true_alpha=mean_true_alpha,\
                                        theta_test = theta_test, \
                                        radio_map = radio_map, \
                                         radio_map_knn = radio_map_knn,
                                        loc_true = location_user_target,\
                                       std_per_dim_alpha=std_per_dim_alpha,\
                                       noiseSTD_per_dim=noiseSTD_per_dim, tau=tau))